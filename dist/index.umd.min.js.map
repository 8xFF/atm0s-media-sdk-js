{"version":3,"file":"index.umd.min.js","sources":["../src/lib/utils/http.ts","../src/lib/core/gateway.ts","../src/lib/utils/shared.ts","../src/lib/utils/typed-event-emitter.ts","../src/lib/utils/types.ts","../src/lib/utils/rtc-peer.ts","../src/lib/core/socket.ts","../src/lib/core/tracks.ts","../src/lib/receiver.ts","../src/lib/sender.ts","../src/lib/core/rpc.ts","../src/lib/session.ts","../src/index.ts"],"sourcesContent":["export function httpPost<T>(url: string, body: unknown): Promise<T> {\n  const myHeaders = new Headers();\n  myHeaders.append('Content-Type', 'application/json');\n\n  const raw = JSON.stringify(body);\n\n  const requestOptions = {\n    method: 'POST',\n    headers: myHeaders,\n    body: raw,\n    redirect: 'follow' as RequestRedirect,\n  };\n\n  return fetch(url, requestOptions)\n    .then((response) => response.text())\n    .then((result) => JSON.parse(result));\n}\n\nexport function httpGet<T>(url: string): Promise<T> {\n  const myHeaders = new Headers();\n  myHeaders.append('Content-Type', 'application/json');\n\n  const requestOptions = {\n    method: 'GET',\n    headers: myHeaders,\n    redirect: 'follow' as RequestRedirect,\n  };\n\n  return fetch(url, requestOptions)\n    .then((response) => response.text())\n    .then((result) => JSON.parse(result));\n}\n","import { httpGet, httpPost } from '../utils/http';\nimport _debug from 'debug';\n\nexport interface IConnectConfig {\n  room: string;\n  peer: string;\n  token: string;\n  sdp: string;\n  mix_minus_audio?: string;\n  codecs?: string[];\n  senders: {\n    uuid: string;\n    label: string;\n    kind: string;\n    simulcast?: boolean;\n    max_bitrate?: number;\n    content_hint?: string;\n    screen?: boolean;\n  }[];\n  receivers: {\n    audio: number;\n    video: number;\n  };\n}\n\nexport interface IConnectResponse {\n  status: boolean;\n  data: {\n    node_id: number;\n    conn_id: string;\n    sdp: string;\n  };\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  error: any;\n}\n\n/**\n * Represents a media server gateway connector.\n */\nexport interface IMediaGatewayConnector {\n  /**\n   * Selects a media stream from the given URLs.\n   * @param urls - The URLs of the media streams.\n   * @returns A promise that resolves to the selected media stream.\n   */\n  selectFromUrls(urls: string | string[]): Promise<string>;\n\n  /**\n   * Connects to the media server using the provided configuration.\n   * @param url - The URL of the media server.\n   * @param config - The connection configuration.\n   */\n  connect(url: string, config: IConnectConfig): Promise<IConnectResponse>;\n\n  /**\n   * Sends a ice candidate update to the media server.\n   * @param url - The URL of the media server.\n   * @param nodeId - The ID of the node.\n   * @param connId - The ID of the connection.\n   * @param ice - The ICE candidate event.\n   */\n  iceCandidate(\n    url: string,\n    nodeId: number,\n    connId: string,\n    ice: RTCPeerConnectionIceEvent,\n  ): void;\n}\n\nexport class MediaGatewayConnector implements IMediaGatewayConnector {\n  private _log = _debug('atm0s:media-server');\n\n  constructor(private _url?: string) {}\n\n  public get url(): string | undefined {\n    return this._url;\n  }\n\n  public async selectFromUrls(urls: string | string[]): Promise<string> {\n    if (typeof urls === 'string') {\n      return (this._url = urls);\n    }\n\n    const waiting_urls: { [url: string]: boolean } = {};\n\n    for (const url of urls) {\n      waiting_urls[url] = true;\n      try {\n        const res = await httpGet<{\n          status: boolean;\n          data: { ready: boolean };\n        }>(url + '/healthcheck?ts=' + new Date().getTime());\n        if (res.status === true && res.data && res.data.ready === true) {\n          return url;\n        }\n      } catch (err) {\n        delete waiting_urls[url];\n        this._log('selectFromUrls :: error:', waiting_urls, url, err);\n      }\n    }\n\n    throw new Error('No available media server');\n  }\n\n  async connect(\n    url: string,\n    config: IConnectConfig,\n  ): Promise<IConnectResponse> {\n    this._log('connect :: connect to media server:', this._url);\n    return httpPost<IConnectResponse>(url + '/webrtc/connect', config);\n  }\n\n  async iceCandidate(\n    url: string,\n    nodeId: number,\n    connId: string,\n    ice: RTCPeerConnectionIceEvent,\n  ) {\n    this._log('iceCandidate :: ice candidate to media server:', url);\n\n    const body = {\n      node_id: nodeId,\n      conn_id: connId,\n      candidate: ice.candidate?.candidate || '',\n      sdp_mid: ice.candidate?.sdpMid || '',\n      sdp_mline_index: ice.candidate?.sdpMLineIndex || 0,\n      username_fragment: ice.candidate?.usernameFragment || '',\n    };\n\n    const res = await httpPost(url + '/webrtc/ice_remote', body);\n    this._log('iceCandidate :: ice candidate response:', res);\n  }\n}\n","import type { StreamKinds } from './types';\n\n/**\n * Generates a random SSRC (Synchronization Source) number.\n *\n * @remarks\n * This function generates a random 32-bit integer that can be used as an SSRC number.\n *\n * @returns A random SSRC number.\n */\nexport function randomSSRC() {\n  return Math.floor(Math.random() * 99999999) + 10000000;\n}\n\n/**\n * Generates a random string of the specified size.\n * @param size The size of the string to generate.\n * @returns A random string of the specified size.\n */\nexport function randomString(size: number) {\n  let text = '';\n  const possible =\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  for (let i = 0; i < size; i++)\n    text += possible.charAt(Math.floor(Math.random() * possible.length));\n  return text;\n}\n\n/**\n * Delays the execution of the function that calls it for a specified number of milliseconds.\n * @param ms - The number of milliseconds to delay the execution.\n * @returns A promise that resolves after the specified delay.\n */\nexport async function delay(ms: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport type Constructor<T = {}> = new (...args: unknown[]) => T;\n\nexport function applyMixin(\n  target: Constructor,\n  mixin: Constructor,\n  includeConstructor = false,\n): void {\n  // Figure out the inheritance chain of the mixin\n  const inheritanceChain: Constructor[] = [mixin];\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const current = inheritanceChain[0];\n    const base = Object.getPrototypeOf(current);\n    if (base?.prototype) {\n      inheritanceChain.unshift(base);\n    } else {\n      break;\n    }\n  }\n  for (const ctor of inheritanceChain) {\n    for (const prop of Object.getOwnPropertyNames(ctor.prototype)) {\n      // Do not override the constructor\n      if (includeConstructor || prop !== 'constructor') {\n        Object.defineProperty(\n          target.prototype,\n          prop,\n          Object.getOwnPropertyDescriptor(ctor.prototype, prop) ??\n            Object.create(null),\n        );\n      }\n    }\n  }\n}\n\nexport function getTrack(\n  stream: MediaStream | undefined | null,\n  kind: StreamKinds,\n) {\n  if (!stream) {\n    return undefined;\n  }\n  if (kind === 'audio') {\n    return stream.getAudioTracks()[0];\n  }\n  if (kind === 'video') {\n    return stream.getVideoTracks()[0];\n  }\n  return undefined;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { applyMixin } from './shared';\n\nclass EventEmitter {\n  events: any = {};\n\n  emit(event: string, ...args: any) {\n    for (const i of this.events[event] || []) {\n      i(...args);\n    }\n  }\n\n  on(event: string, cb: any) {\n    (this.events[event] = this.events[event] || []).push(cb);\n    return () =>\n      (this.events[event] = this.events[event].filter((i: any) => i !== cb));\n  }\n\n  off(event: string, cb: any) {\n    this.events[event] = this.events[event].filter((i: any) => i !== cb);\n  }\n\n  offAllListeners() {\n    this.events = {};\n  }\n\n  removeAllListeners() {\n    this.offAllListeners();\n  }\n\n  removeListener(event: string, cb: any) {\n    this.off(event, cb);\n  }\n\n  listeners(event: string) {\n    return this.events[event];\n  }\n\n  listenerCount(event: string) {\n    return this.events[event].length;\n  }\n}\n\nexport type EventHandler =\n  // Add more overloads as necessary\n  | ((arg1: any, arg2: any, arg3: any, arg4: any) => void)\n  | ((arg1: any, arg2: any, arg3: any) => void)\n  | ((arg1: any, arg2: any) => void)\n  | ((arg1: any) => void)\n  | ((...args: any[]) => void);\n\nexport interface TypedEventEmitter<\n  TEvents extends Record<keyof TEvents, EventHandler>,\n> {\n  on<TEvent extends keyof TEvents>(\n    event: TEvent,\n    callback: TEvents[TEvent],\n  ): this;\n  removeListener<TEvent extends keyof TEvents>(\n    event: TEvent,\n    callback: TEvents[TEvent],\n  ): this;\n  off<TEvent extends keyof TEvents>(\n    event: TEvent,\n    callback: TEvents[TEvent],\n  ): this;\n\n  offAllListeners(): this;\n  removeAllListeners(): this;\n\n  emit<TEvent extends keyof TEvents>(\n    event: TEvent,\n    ...args: Parameters<TEvents[TEvent]>\n  ): boolean;\n\n  listeners<TEvent extends keyof TEvents>(eventName: TEvent): TEvents[TEvent][];\n  listenerCount<TEvent extends keyof TEvents>(\n    event: TEvent,\n    listener?: TEvents[TEvent],\n  ): number;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class TypedEventEmitter<\n  TEvents extends Record<keyof TEvents, EventHandler>,\n> {}\n\n// Make TypedEventEmitter inherit from EventEmitter without actually extending\napplyMixin(TypedEventEmitter, EventEmitter);\n","export enum StreamKinds {\n  AUDIO = 'audio',\n  VIDEO = 'video',\n}\n\nexport enum Codecs {\n  OPUS = 'OPUS',\n  VP8 = 'VP8',\n  VP9 = 'VP9',\n  H264 = 'H264',\n}\n\nexport enum ContentHint {\n  None = 'none',\n  Motion = 'motion',\n  Detail = 'detail',\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type AnyFunction = (...args: any[]) => any;\n\nexport enum LatencyMode {\n  UltraLow = 'ultra-low',\n  Default = 'default',\n  Smooth200 = 'smooth-200',\n  Smooth500 = 'smooth-500',\n  Smooth800 = 'smooth-800',\n  Smooth1000 = 'smooth-1000',\n  Smooth2000 = 'smooth-2000',\n}\n\nexport type SenderConfig = {\n  stream?: MediaStream | null;\n  name: string;\n  kind: StreamKinds;\n  preferredCodecs?: Codecs[];\n  simulcast?: boolean;\n  maxBitrate?: number;\n  contentHint?: ContentHint;\n  screen?: boolean;\n};\n\n/**\n * Mapping of latency modes to maximum packets.\n * This is to configure Audio Jitter Buffer Max Packets for React Native WebRTC.\n *\n */\nexport const LatencyMode2MaxPackets = {\n  [LatencyMode.UltraLow]: [10, 10],\n  [LatencyMode.Smooth200]: [20, 20],\n  [LatencyMode.Smooth500]: [25, 25],\n  [LatencyMode.Smooth800]: [40, 40],\n  [LatencyMode.Smooth1000]: [50, 50],\n  [LatencyMode.Smooth2000]: [100, 100],\n  [LatencyMode.Default]: [undefined, undefined],\n};\n\n/**\n * Mapping of latency modes to playout delay hints. Also for React Native WebRTC, maybe?\n */\nexport const LatencyMode2DelayHint = {\n  [LatencyMode.UltraLow]: 0,\n  [LatencyMode.Smooth200]: 0.2,\n  [LatencyMode.Smooth500]: 0.5,\n  [LatencyMode.Smooth800]: 0.8,\n  [LatencyMode.Smooth1000]: 1,\n  [LatencyMode.Smooth2000]: 2,\n  [LatencyMode.Default]: undefined,\n};\n","export interface RTCRtpTransceiverInitExtended extends RTCRtpTransceiverInit {\n  simulcast?: boolean;\n  isScreen?: boolean;\n  maxBitrate?: number;\n  preferredCodecs?: { kind: string; codecs: string[] };\n}\n\nexport class RTCPeerConnectionAugmented extends RTCPeerConnection {\n  constructor(configuration?: RTCConfiguration) {\n    super(configuration);\n  }\n\n  override addTransceiver(\n    trackOrKind: MediaStreamTrack | string,\n    init?: RTCRtpTransceiverInitExtended,\n  ): RTCRtpTransceiver {\n    const transceiver = super.addTransceiver(trackOrKind, init);\n    if (init?.simulcast) {\n      if (transceiver && transceiver.sender) {\n        const parameters = transceiver.sender.getParameters();\n        parameters.encodings = init?.isScreen\n          ? [\n              { rid: '1', active: true },\n              { rid: '0', active: true },\n            ]\n          : [\n              {\n                rid: '2',\n                active: true,\n                ...(init?.maxBitrate && {\n                  maxBitrate: Math.floor((init?.maxBitrate * 5) / 8),\n                }),\n              },\n              {\n                rid: '1',\n                active: true,\n                ...(init?.maxBitrate && {\n                  maxBitrate: Math.floor((init?.maxBitrate * 2) / 8),\n                }),\n                scaleResolutionDownBy: 2,\n              },\n              {\n                rid: '0',\n                active: true,\n                ...(init?.maxBitrate && {\n                  maxBitrate: Math.floor((init?.maxBitrate * 1) / 8),\n                }),\n                scaleResolutionDownBy: 2,\n              },\n            ];\n        transceiver.sender.setParameters(parameters);\n      }\n    }\n\n    if (init?.preferredCodecs) {\n      const codecs = RTCRtpSender.getCapabilities(init.preferredCodecs.kind)\n        ?.codecs;\n      if (!codecs) return transceiver;\n      codecs.sort((c1, c2) => {\n        let c1_index = init.preferredCodecs?.codecs.indexOf(\n          c1.mimeType.replace('video/', ''),\n        );\n        let c2_index = init.preferredCodecs?.codecs.indexOf(\n          c2.mimeType.replace('video/', ''),\n        );\n\n        if (c1_index! < 0) c1_index = 1000;\n        if (c2_index! < 0) c2_index = 1000;\n        if (c1_index! < c2_index!) {\n          return -1;\n        }\n        if (c1_index! > c2_index!) {\n          return 1;\n        }\n        return 0;\n      });\n      transceiver.setCodecPreferences(codecs);\n    }\n    return transceiver;\n  }\n}\n","import type { IMediaGatewayConnector } from './gateway';\nimport type { ISessionConfig } from '../utils/interface';\nimport { TypedEventEmitter } from '../utils/typed-event-emitter';\nimport _debug from 'debug';\nimport {\n  LatencyMode,\n  LatencyMode2MaxPackets,\n  StreamKinds,\n  type SenderConfig,\n} from '../utils/types';\nimport { delay, getTrack } from '../utils/shared';\nimport pako from 'pako';\nimport { RTCPeerConnectionAugmented } from '../utils/rtc-peer';\nimport { ReceiverTrack, SenderTrack } from './tracks';\n\nexport enum RealtimeSocketEvent {\n  Message = 'message',\n  State = 'state',\n}\n\nexport enum RealtimeSocketState {\n  Created = 'created',\n  Connecting = 'connecting',\n  Connected = 'connected',\n  Disconnected = 'disconnected',\n  Failed = 'failed',\n  Closed = 'closed',\n}\n\nexport interface IRealtimeSocketCallbacks {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  message: (data: any) => void;\n  peer_state: (state: RealtimeSocketState) => void;\n  dc_state: (state: RealtimeSocketState) => void;\n}\n\nexport interface IRealtimeSocket\n  extends TypedEventEmitter<IRealtimeSocketCallbacks> {\n  connect(\n    connector: IMediaGatewayConnector,\n    config: ISessionConfig,\n  ): Promise<void>;\n  // reconnect(connector: IMediaGatewayConnector): Promise<void>;\n\n  createReceiverTrack(id: string, kind: StreamKinds): ReceiverTrack;\n  createSenderTrack(cfg: SenderConfig): SenderTrack;\n\n  generateOffer(): Promise<{\n    offer: RTCSessionDescriptionInit;\n    meta: {\n      sdp: string;\n      senders: {\n        uuid: string;\n        label: string;\n        kind: StreamKinds;\n        screen: boolean;\n      }[];\n      receivers: {\n        audio: number;\n        video: number;\n      };\n    };\n  }>;\n\n  updateSdp(\n    localOffer: RTCSessionDescriptionInit,\n    remoteAnswerSdp: string,\n  ): void;\n\n  send(data: string | Uint8Array): void;\n\n  close(): void;\n}\n\nexport interface IRealtimeSocketOptions {\n  iceServers?: RTCIceServer[];\n  latencyMode?: LatencyMode;\n}\n\nexport class RealtimeSocket\n  extends TypedEventEmitter<IRealtimeSocketCallbacks>\n  implements IRealtimeSocket\n{\n  private _log = _debug('atm0s:realtime-socket');\n  private _pConnState: RealtimeSocketState = RealtimeSocketState.Created;\n  private _dcState: RealtimeSocketState = RealtimeSocketState.Created;\n  private _lc?: RTCPeerConnectionAugmented;\n  private _dc?: RTCDataChannel;\n  private _sendStreams = new Map<string, SenderTrack>();\n  private _recvStreams = new Map<string, ReceiverTrack>();\n\n  private _msg_encoder = new TextEncoder();\n\n  constructor(\n    private _urls: string | string[],\n    private _options?: IRealtimeSocketOptions,\n  ) {\n    super();\n    const peerConfig: RTCConfiguration = {\n      iceServers: this._options?.iceServers || [],\n      ...(this._options?.latencyMode &&\n        this._options.latencyMode in LatencyMode2MaxPackets && {\n          audioJitterBufferMaxPackets:\n            LatencyMode2MaxPackets[this._options.latencyMode],\n          rtcAudioJitterBufferMaxPackets:\n            LatencyMode2MaxPackets[this._options.latencyMode],\n        }),\n    };\n    this._lc = new RTCPeerConnectionAugmented(peerConfig);\n    this._dc = this._lc.createDataChannel('data', {\n      ordered: false,\n      maxPacketLifeTime: 10000,\n    });\n  }\n\n  public async connect(\n    connector: IMediaGatewayConnector,\n    config: ISessionConfig,\n  ) {\n    this._log('connect :: connecting to %s', this._urls);\n    this._pConnState = RealtimeSocketState.Connecting;\n\n    const serverUrl = await connector.selectFromUrls(this._urls);\n    this._log('connect :: try connect to media server:', serverUrl);\n\n    this._lc!.ontrack = (event: RTCTrackEvent) => {\n      if (event.streams.length === 0) {\n        this._log('connect :: no stream found');\n        return;\n      }\n      const stream = event.streams[0];\n      const track = event.track;\n\n      this._log('connect :: received track:', track, stream);\n\n      for (const receiver of this._recvStreams.values()) {\n        if (\n          receiver.info.remoteId === stream?.id &&\n          receiver.stream.getTracks().length === 0 &&\n          receiver.info.kind === track.kind\n        ) {\n          receiver.stream = stream;\n          receiver.stream.addTrack(track);\n          // this.emit(RealtimeSocketEvent.Message, receiver);\n        }\n      }\n    };\n\n    this._lc!.onconnectionstatechange = () => {\n      this._log('connection state changed:', this._lc!.connectionState);\n      switch (this._lc!.connectionState) {\n        case 'connected':\n          this.setConnState(RealtimeSocketState.Connected);\n          break;\n        case 'disconnected':\n          this.setConnState(RealtimeSocketState.Disconnected);\n          break;\n        case 'failed':\n          this.setConnState(RealtimeSocketState.Failed);\n          throw new Error('Peer Connection failed');\n          break;\n        case 'closed':\n          this.setConnState(RealtimeSocketState.Closed);\n          break;\n      }\n    };\n\n    this._dc!.onmessage = (event) => {\n      this.emit(RealtimeSocketEvent.Message, event.data);\n    };\n    this._dc!.onopen = () => {\n      this.setDcState(RealtimeSocketState.Connected);\n      this._log('datachannel connect :: opended');\n    };\n    this._dc!.onerror = (err) => {\n      this.setDcState(RealtimeSocketState.Failed);\n      this._log('datachannel connect :: error:', err);\n    };\n    this._dc!.onclose = () => {\n      this.setDcState(RealtimeSocketState.Closed);\n      this._log('datachannel connect :: closed');\n    };\n\n    const offer = await this._lc!.createOffer({\n      offerToReceiveAudio: true,\n      offerToReceiveVideo: false,\n    });\n    this._log('connect :: created offer:', offer);\n\n    const res = await connector.connect(serverUrl, {\n      // TODO: consider remove session config dependency\n      room: config.roomId,\n      peer: config.peerId,\n      token: config.token,\n      sdp: offer.sdp!,\n      // mix_minus_audio: config.mix_minus_audio?.mode,\n      // codecs: config.codecs,\n      senders: Array.from(this._sendStreams.values()).map((s) => ({\n        uuid: s.uuid,\n        label: s.info.label,\n        kind: s.info.kind,\n        screen: s.info.screen,\n      })),\n      receivers: {\n        audio: Array.from(this._recvStreams.values()).filter(\n          (s) => s.info.kind === StreamKinds.AUDIO,\n        ).length,\n        video: Array.from(this._recvStreams.values()).filter(\n          (s) => s.info.kind === StreamKinds.VIDEO,\n        ).length,\n      },\n    });\n    if (!res.status) {\n      this._log('connect :: failed to connect:', res);\n      throw new Error(res.error);\n    }\n    const nodeId = res.data.node_id;\n    const connId = res.data.conn_id;\n    const sdp = res.data.sdp;\n\n    this._log('connect :: received answer:', nodeId, connId, sdp);\n    this._lc!.onicecandidate = async (ice) => {\n      if (ice && ice.candidate)\n        await connector.iceCandidate(serverUrl, nodeId, connId, ice);\n    };\n    this._lc!.setLocalDescription(offer);\n    this._lc!.setRemoteDescription(\n      new RTCSessionDescription({ sdp, type: 'answer' }),\n    );\n  }\n\n  private setConnState(state: RealtimeSocketState) {\n    this._pConnState = state;\n    this.emit('peer_state', this._pConnState);\n  }\n\n  private setDcState(state: RealtimeSocketState) {\n    this._dcState = state;\n    this.emit('dc_state', this._dcState);\n  }\n\n  // public async reconnect(connector: IMediaGatewayConnector) {\n  //   // TODO: implement reconnect\n  //   // this.close();\n  //   // this.connect(connector);\n  // }\n\n  public createReceiverTrack(id: string, kind: StreamKinds): ReceiverTrack {\n    this._log('createReceiverTrack :: kind:', kind);\n    const stream = new MediaStream();\n    this._lc?.addTransceiver(kind, {\n      direction: 'recvonly',\n    });\n    const track = new ReceiverTrack(stream, {\n      remoteId: id,\n      kind: kind,\n    });\n    this._recvStreams.set(track.uuid, track);\n    // TODO: Latency mode\n    return track;\n  }\n\n  public createSenderTrack(cfg: SenderConfig): SenderTrack {\n    this._log('createSenderTrack :: kind:', cfg.kind);\n    const track = getTrack(cfg.stream, cfg.kind);\n    const label = track?.label || 'not-supported';\n\n    const transceiver = this._lc?.addTransceiver(track!, {\n      direction: 'sendonly',\n      streams: [cfg.stream!],\n      preferredCodecs: {\n        kind: cfg.kind,\n        codecs: cfg.preferredCodecs!,\n      },\n      simulcast: cfg.simulcast,\n      maxBitrate: cfg.maxBitrate,\n      isScreen: cfg.screen,\n    });\n    const senderTrack = new SenderTrack(\n      cfg.stream || null,\n      {\n        label: label,\n        kind: cfg.kind,\n        name: cfg.name,\n        screen: !!cfg.screen,\n      },\n      transceiver,\n    );\n    this._sendStreams.set(senderTrack.uuid, senderTrack);\n    return senderTrack;\n  }\n\n  public async generateOffer() {\n    const offer = await this._lc!.createOffer({\n      offerToReceiveAudio: true,\n      offerToReceiveVideo: true,\n    });\n    const meta = {\n      sdp: offer.sdp!,\n      senders: Array.from(this._sendStreams.values()).map((s) => ({\n        uuid: s.uuid,\n        label: s.info.label,\n        kind: s.info.kind,\n        screen: s.info.screen,\n      })),\n      receivers: {\n        audio: Array.from(this._recvStreams.values()).filter(\n          (s) => s.info.kind === StreamKinds.AUDIO,\n        ).length,\n        video: Array.from(this._recvStreams.values()).filter(\n          (s) => s.info.kind === StreamKinds.VIDEO,\n        ).length,\n      },\n    };\n    return { offer, meta };\n  }\n\n  public updateSdp(\n    localOffer: RTCSessionDescriptionInit,\n    remoteAnswerSdp: string,\n  ) {\n    this._log('updateSdp :: local offer:', localOffer);\n    this._log('updateSdp :: remote answer sdp:', remoteAnswerSdp);\n    this._lc!.setLocalDescription(localOffer);\n    this._lc!.setRemoteDescription(\n      new RTCSessionDescription({ sdp: remoteAnswerSdp, type: 'answer' }),\n    );\n  }\n\n  public send(data: string | Uint8Array) {\n    const msg =\n      typeof data !== 'string' ? data : this._msg_encoder.encode(data);\n    if (data.length < 1000) {\n      this._dc?.send(msg);\n    } else {\n      const compressed = pako.deflate(msg);\n      this._dc?.send(compressed);\n    }\n  }\n\n  async close() {\n    this._dc?.close();\n    await delay(500);\n    this._lc?.close();\n  }\n}\n","import type { ReceiverInfo, SenderInfo } from '../utils/interface';\nimport { getTrack } from '../utils/shared';\n\nexport class SenderTrack {\n  private static seed = 0;\n  public uuid: string;\n  constructor(\n    public stream: MediaStream | null,\n    public info: SenderInfo,\n    public transceiver?: RTCRtpTransceiver,\n  ) {\n    this.uuid = `sender-${info.kind}-${SenderTrack.seed++}`;\n  }\n\n  replaceStream(stream: MediaStream | null) {\n    if (stream === this.stream) {\n      return;\n    }\n    this.stream = stream;\n    if (this.transceiver) {\n      this.transceiver.sender.replaceTrack(\n        getTrack(stream, this.info.kind) || null,\n      );\n    }\n  }\n\n  getTrack() {\n    return getTrack(this.stream, this.info.kind);\n  }\n}\n\nexport class ReceiverTrack {\n  private static seed = 0;\n  public uuid: string;\n  constructor(\n    public stream: MediaStream,\n    public info: ReceiverInfo,\n  ) {\n    const track = this.getTrack();\n    this.uuid = track?.id || `receiver-${info.kind}-${ReceiverTrack.seed++}`;\n  }\n\n  getTrack() {\n    return getTrack(this.stream, this.info.kind);\n  }\n}\n","import type { ReceiverTrack } from './utils/interface';\nimport type { IRPC } from './core/rpc';\nimport { TypedEventEmitter } from './utils/typed-event-emitter';\nimport _debug from 'debug';\n\nexport interface IStreamReceiver {\n  switch(name: string, peerId: string, priority?: number): Promise<boolean>;\n  limit(\n    priority: number,\n    max_spatial: number,\n    max_temporal: number,\n  ): Promise<boolean>;\n  stop(): Promise<boolean>;\n}\n\nexport enum StreamReceiverState {\n  NoSource = 'no_source',\n  Connecting = 'connecting',\n  Live = 'live',\n  Pause = 'paused',\n  KeyOnly = 'key_only',\n  SourceDeactived = 'source_deactived',\n}\n\nexport interface IStreamReceiverCallbacks {\n  state: (state: StreamReceiverState) => void;\n  audio_level: (level: number) => void;\n}\n\nexport class StreamReceiver\n  extends TypedEventEmitter<IStreamReceiverCallbacks>\n  implements IStreamReceiver\n{\n  kind: string;\n  remoteId: string;\n  hasTrack: boolean = false;\n  hasTrackPromises: Array<(value: unknown) => void> = [];\n  private _state: StreamReceiverState = StreamReceiverState.NoSource;\n  private _log = _debug('atm0s:stream-receiver');\n\n  constructor(\n    private _rpc: IRPC,\n    private _track: ReceiverTrack,\n  ) {\n    super();\n    this.kind = this._track.info.kind;\n    this.remoteId = this._track.info.remoteId;\n    this._rpc.on(`local_stream_${this.remoteId}_audio_level`, (_, info) => {\n      this._setState(info.state);\n    });\n    this._rpc.on(`local_stream_${this.remoteId}_state`, (_, info) => {\n      this.emit('audio_level', info.level);\n    });\n  }\n\n  private _setState(state: StreamReceiverState) {\n    this._state = state;\n    this.emit('state', state);\n  }\n\n  private async internalReady() {\n    if (this.hasTrack) return true;\n    return new Promise((resolve) => {\n      this.hasTrackPromises.push(resolve); //this ensure checking order\n    });\n  }\n\n  async switch(name: string, peerId: string, priority: number = 50) {\n    this._log('switch stream', name, peerId);\n    await this.internalReady();\n    if (this._track.stream) {\n      this._setState(StreamReceiverState.Connecting);\n      const res = await this._rpc.request<unknown, { status: boolean }>(\n        'receiver.switch',\n        {\n          id: this.remoteId,\n          priority,\n          remote: { peer: peerId, stream: name },\n        },\n      );\n      if (res.status === true) {\n        return true;\n      } else {\n        this._setState(StreamReceiverState.NoSource);\n        return false;\n      }\n    }\n    return false;\n  }\n\n  async limit(\n    priority: number,\n    max_spatial: number,\n    max_temporal: number,\n  ): Promise<boolean> {\n    this._log('limit stream', priority, max_spatial, max_temporal);\n    await this.internalReady();\n    if (this._track.stream) {\n      const res = await this._rpc.request<unknown, { status: boolean }>(\n        'receiver.limit',\n        {\n          id: this.remoteId,\n          priority,\n          max_spatial,\n          max_temporal,\n        },\n      );\n      if (res.status === true) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n    return false;\n  }\n\n  async stop() {\n    if (this._state === StreamReceiverState.NoSource) {\n      return true;\n    }\n    const res = await this._rpc.request<{ id: string }, { status: boolean }>(\n      'receiver.disconnect',\n      {\n        id: this.remoteId,\n      },\n    );\n    if (res.status === true) {\n      this._setState(StreamReceiverState.NoSource);\n      return true;\n    }\n    return false;\n  }\n}\n","import type { IRPC } from './core/rpc';\nimport type { SenderTrack } from './core/tracks';\nimport { TypedEventEmitter } from './utils/typed-event-emitter';\nimport { StreamKinds } from './utils/types';\nimport _debug from 'debug';\n\nexport interface IStreamSender\n  extends TypedEventEmitter<IStreamSenderCallbacks> {\n  switch(stream: MediaStream): void;\n  stop(): Promise<void>;\n}\n\nexport enum StreamSenderState {\n  Created = 'created',\n  Connecting = 'connecting',\n  Connected = 'connected',\n  Deactivated = 'deactived',\n  Closed = 'closed',\n}\n\nexport interface IStreamSenderCallbacks {\n  state: (state: StreamSenderState) => void;\n  audio_level: (level: number) => void;\n}\n\nexport class StreamSender\n  extends TypedEventEmitter<IStreamSenderCallbacks>\n  implements IStreamSender\n{\n  kind: StreamKinds;\n  name: string;\n\n  private _state: StreamSenderState = StreamSenderState.Created;\n  private _log = _debug('atm0s:stream-sender');\n  constructor(\n    private _rpc: IRPC,\n    private _track: SenderTrack,\n  ) {\n    super();\n    this.kind = this._track.info.kind;\n    this.name = this._track.info.name;\n    this._rpc.on(`remote_stream_${this.name}_state`, () => {\n      if (this._state === StreamSenderState.Connecting) {\n        this._setState(StreamSenderState.Connected);\n      }\n    });\n    this._rpc.on(`remote_stream_${this.name}_audio_level`, (_, info) => {\n      this.emit('audio_level', info.level);\n    });\n  }\n\n  private _setState(state: StreamSenderState) {\n    this._state = state;\n    this.emit('state', state);\n  }\n\n  switch(stream: MediaStream | null) {\n    this._log('switch stream', stream);\n    this._track.replaceStream(stream);\n    this._rpc.request('sender.toggle', {\n      name: this.name,\n      kind: this.kind,\n      track: this._track.uuid,\n    });\n    if (stream) {\n      this._setState(StreamSenderState.Connected);\n    } else {\n      this._setState(StreamSenderState.Deactivated);\n    }\n  }\n\n  async stop() {\n    if (this._state === StreamSenderState.Closed) {\n      return;\n    }\n    this._setState(StreamSenderState.Closed);\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport pako from 'pako';\nimport { RealtimeSocketState, type IRealtimeSocket } from './socket';\nimport _debug from 'debug';\nimport type { AnyFunction } from '../utils/types';\n\nexport interface IRPC {\n  request<DataType, ResponseType>(\n    cmd: string,\n    data: DataType,\n  ): Promise<ResponseType>;\n  // event<T>(cmd: string, data: T): void;\n\n  on(cmd: string, handler: AnyFunction): void;\n  off(cmd: string): void;\n}\n\nexport class RpcRequest {\n  createdAt: Date;\n\n  constructor(\n    public reqId: number,\n    private method: string,\n    private params: any,\n    public resolve: (data: any) => void,\n    public reject: (error: any) => void,\n  ) {\n    this.createdAt = new Date();\n  }\n\n  toJson() {\n    return {\n      req_id: this.reqId,\n      type: 'request',\n      request: this.method,\n      data: this.params,\n    };\n  }\n}\n\nexport class RPC implements IRPC {\n  private _reqSeed = 0;\n  private _msgDecoder = new TextDecoder();\n  private _log = _debug('atm0s:rpc');\n  private _handlers: Map<string, AnyFunction> = new Map();\n  private _reqs: Map<number, RpcRequest> = new Map();\n\n  connected = false;\n\n  constructor(private _socket: IRealtimeSocket) {\n    this._socket.on('message', this._prereceiveMessage);\n    this._socket.on('dc_state', (state) => {\n      if (state === RealtimeSocketState.Connected) {\n        this.connected = true;\n      }\n    });\n  }\n\n  private _prereceiveMessage = (data: any) => {\n    if (data instanceof Blob) {\n      const reader = new FileReader();\n      reader.onload = () => {\n        const compressed = new Uint8Array(reader.result as ArrayBuffer);\n        const decompressed = pako.inflate(compressed);\n        const msg = this._msgDecoder.decode(decompressed);\n        this._onReceiveMessage(msg);\n      };\n      reader.readAsArrayBuffer(data);\n    } else if (data instanceof ArrayBuffer) {\n      const decompressed = pako.inflate(data);\n      const msg = this._msgDecoder.decode(decompressed);\n      this._log('decompress', data.byteLength, msg, msg.length);\n      this._onReceiveMessage(msg);\n    } else {\n      this._onReceiveMessage(data);\n    }\n  };\n\n  private _onReceiveMessage = (msg: string) => {\n    this._log('datachannel on message:', msg);\n    const json = JSON.parse(msg);\n\n    const type = json.type;\n    if (type === 'event') {\n      const handler = this._handlers.get(json.event);\n      if (handler) {\n        handler(json.event, json.data);\n      }\n    } else if (type === 'request') {\n      this._socket.send(\n        JSON.stringify({\n          type: 'answer',\n          status: false,\n          error: 'NOT_SUPPORT',\n        }),\n      );\n    } else if (type === 'answer') {\n      const req = this._reqs.get(json.req_id);\n      if (req) {\n        if (json.success === true) {\n          req.resolve({\n            status: true,\n            data: json.data,\n          });\n        } else {\n          req.resolve({\n            status: false,\n            error: json.error,\n          });\n        }\n      } else {\n        this._log;\n      }\n    }\n  };\n\n  request(cmd: string, data: any): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const req = new RpcRequest(this._reqSeed++, cmd, data, resolve, reject);\n      this._reqs.set(req.reqId, req);\n      this._socket.send(JSON.stringify(req.toJson()));\n    });\n  }\n\n  // event(cmd: string, data: any): void {\n  //   const event = {\n  //     req_id: this.reqId,\n  //     type: 'request',\n  //     request: this.method,\n  //     data: this.params,\n  //   };\n  // }\n\n  on(cmd: string, handler: (data: any) => void): void {\n    this._handlers.set(cmd, handler);\n  }\n\n  off(cmd: string): void {\n    this._handlers.delete(cmd);\n  }\n}\n","import type { IMediaGatewayConnector } from './core/gateway';\nimport type { ISessionConfig } from './utils/interface';\nimport { StreamReceiver } from './receiver';\nimport { RPC, type IRPC } from './core/rpc';\nimport { StreamSender } from './sender';\nimport { type IRealtimeSocket } from './core/socket';\nimport { StreamKinds, type SenderConfig } from './utils/types';\nimport { debounce } from 'ts-debounce';\nimport _debug from 'debug';\n\nexport class Session {\n  private _audioSenders = new Map<string, StreamSender>();\n  private _videoSenders = new Map<string, StreamSender>();\n\n  private _audioReceivers: StreamReceiver[] = [];\n  private _videoReceivers: StreamReceiver[] = [];\n\n  private _log = _debug('atm0s:session');\n  private _rpc: IRPC;\n\n  constructor(\n    private _cfg: ISessionConfig,\n    private _socket: IRealtimeSocket,\n    private _connector: IMediaGatewayConnector,\n  ) {\n    this._socket.on('message', (data) => {\n      console.log('message', data);\n    });\n    this._socket.on('peer_state', (data) => {\n      console.log('state', data);\n    });\n    this._socket.on('dc_state', (data) => {\n      console.log('dc_state', data);\n    });\n    this._rpc = new RPC(this._socket);\n  }\n\n  async connect() {\n    this._log('start to connect ...');\n    this._cfg.senders.map((s) => {\n      if (s.stream) {\n        const senderTrack = this._socket.createSenderTrack(s);\n        const sender = new StreamSender(this._rpc, senderTrack);\n        if (senderTrack.info.kind === StreamKinds.AUDIO) {\n          this._audioSenders.set(s.name, sender);\n        }\n        if (senderTrack.info.kind === StreamKinds.VIDEO) {\n          this._videoSenders.set(s.name, sender);\n        }\n      }\n    });\n    for (let i = 0; i < this._cfg.receivers.audio; i++) {\n      const recvrTrack = this._socket.createReceiverTrack(\n        `audio_${i}`,\n        StreamKinds.AUDIO,\n      );\n      const receiver = new StreamReceiver(this._rpc, recvrTrack);\n      this._audioReceivers.push(receiver);\n    }\n    for (let i = 0; i < this._cfg.receivers.video; i++) {\n      const recvrTrack = this._socket.createReceiverTrack(\n        `video_${i}`,\n        StreamKinds.VIDEO,\n      );\n      const receiver = new StreamReceiver(this._rpc, recvrTrack);\n      this._videoReceivers.push(receiver);\n    }\n\n    return this._socket.connect(this._connector, this._cfg);\n  }\n\n  async createSender(cfg: SenderConfig) {\n    const senderTrack = this._socket.createSenderTrack(cfg);\n    const sender = new StreamSender(this._rpc, senderTrack);\n    if (cfg.kind === StreamKinds.AUDIO) {\n      this._audioSenders.set(cfg.name, sender);\n    }\n    if (cfg.kind === StreamKinds.VIDEO) {\n      this._videoSenders.set(cfg.name, sender);\n    }\n    this.update();\n    return sender;\n  }\n\n  async createReceiver(kind: StreamKinds) {\n    const recvrTrack = this._socket.createReceiverTrack(\n      `${kind}_${this._audioReceivers.length}`,\n      kind,\n    );\n    const receiver = new StreamReceiver(this._rpc, recvrTrack);\n    if (kind === StreamKinds.AUDIO) {\n      this._audioReceivers.push(receiver);\n    }\n    if (kind === StreamKinds.VIDEO) {\n      this._videoReceivers.push(receiver);\n    }\n    this.update();\n    return receiver;\n  }\n\n  async takeReceiver(kind: StreamKinds) {\n    const receiver =\n      kind === StreamKinds.AUDIO\n        ? this._audioReceivers.shift()\n        : this._videoReceivers.shift();\n    if (!receiver) {\n      throw new Error('NO_RECEIVER');\n    }\n    // this.update();\n    return receiver;\n  }\n\n  async backReceiver(receiver: StreamReceiver) {\n    if (receiver.kind === StreamKinds.AUDIO) {\n      this._audioReceivers.push(receiver);\n    }\n    if (receiver.kind === StreamKinds.VIDEO) {\n      this._videoReceivers.push(receiver);\n    }\n  }\n\n  async getSender(name: string, kind: StreamKinds) {\n    const sender =\n      kind === StreamKinds.AUDIO\n        ? this._audioSenders.get(name)\n        : this._videoSenders.get(name);\n    if (!sender) {\n      throw new Error('NO_SENDER');\n    }\n    return sender;\n  }\n\n  update = debounce(this.updateSdp, 500, {\n    isImmediate: false,\n  });\n\n  private async updateSdp() {\n    const { offer, meta } = await this._socket.generateOffer();\n    this._log('send updated sdp:', meta);\n    const res = await this._rpc!.request<\n      unknown,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      { status: boolean; data: any }\n    >('peer.updateSdp', meta);\n    if (!res.status) {\n      this._log('updateSdp :: Error response from server', res);\n      throw new Error('SERVER_ERROR');\n    }\n    this._log('updateSdp :: received answer:', res.data);\n    this._socket.updateSdp(offer, res.data.sdp);\n  }\n}\n","import { MediaGatewayConnector } from './lib/core/gateway';\nimport { RealtimeSocket } from './lib/core/socket';\nimport { Session } from './lib/session';\nimport type { ISessionConfig } from './lib/utils/interface';\n\nexport function createSession(urls: string | string[], cfg: ISessionConfig) {\n  const socket = new RealtimeSocket(urls);\n  const gateway = new MediaGatewayConnector();\n  return new Session(cfg, socket, gateway);\n}\n"],"names":["httpPost","url","body","myHeaders","Headers","append","raw","JSON","stringify","fetch","method","headers","redirect","then","response","text","result","parse","httpGet","MediaGatewayConnector","_url","this","_log","_debug","Object","defineProperty","prototype","get","selectFromUrls","urls","waiting_urls","urls_1","__values","urls_1_1","next","value","Date","getTime","res","_b","sent","status","data","ready","err_1","Error","connect","config","iceCandidate","nodeId","connId","ice","node_id","conn_id","candidate","_a","sdp_mid","sdpMid","sdp_mline_index","_c","sdpMLineIndex","username_fragment","_d","usernameFragment","_e","delay","ms","Promise","resolve","setTimeout","getTrack","stream","kind","getAudioTracks","getVideoTracks","StreamKinds","Codecs","ContentHint","LatencyMode","EventEmitter","events","emit","event","args","_i","arguments","length","done","apply","__spreadArray","__read","on","cb","_this","push","filter","i","off","offAllListeners","removeAllListeners","removeListener","listeners","listenerCount","TypedEventEmitter","target","mixin","includeConstructor","inheritanceChain","current","base","getPrototypeOf","unshift","inheritanceChain_1","inheritanceChain_1_1","ctor","e_2","getOwnPropertyNames","prop","getOwnPropertyDescriptor","create","applyMixin","LatencyMode2MaxPackets","UltraLow","Smooth200","Smooth500","Smooth800","Smooth1000","Smooth2000","Default","undefined","RealtimeSocketEvent","RealtimeSocketState","RTCPeerConnectionAugmented","_super","configuration","call","__extends","addTransceiver","trackOrKind","init","transceiver","simulcast","sender","parameters","getParameters","encodings","isScreen","rid","active","__assign","maxBitrate","Math","floor","scaleResolutionDownBy","setParameters","preferredCodecs","codecs","RTCRtpSender","getCapabilities","sort","c1","c2","c1_index","indexOf","mimeType","replace","c2_index","setCodecPreferences","RTCPeerConnection","SenderTrack","info","uuid","concat","seed","replaceStream","replaceTrack","ReceiverTrack","track","id","StreamReceiverState","RealtimeSocket","_urls","_options","_pConnState","Created","_dcState","_sendStreams","Map","_recvStreams","_msg_encoder","TextEncoder","peerConfig","iceServers","latencyMode","audioJitterBufferMaxPackets","rtcAudioJitterBufferMaxPackets","_lc","_dc","createDataChannel","ordered","maxPacketLifeTime","connector","Connecting","serverUrl","ontrack","streams","values","receiver","remoteId","getTracks","addTrack","onconnectionstatechange","connectionState","setConnState","Connected","Disconnected","Failed","Closed","onmessage","Message","onopen","setDcState","onerror","err","onclose","createOffer","offerToReceiveAudio","offerToReceiveVideo","offer","room","roomId","peer","peerId","token","sdp","senders","Array","from","map","s","label","screen","receivers","audio","AUDIO","video","VIDEO","error","onicecandidate","__awaiter","setLocalDescription","setRemoteDescription","RTCSessionDescription","type","state","createReceiverTrack","MediaStream","direction","set","createSenderTrack","cfg","senderTrack","name","generateOffer","meta","updateSdp","localOffer","remoteAnswerSdp","send","msg","encode","compressed","pako","deflate","close","StreamSenderState","StreamReceiver","_rpc","_track","hasTrack","hasTrackPromises","_state","NoSource","_","_setState","level","internalReady","switch","priority","request","remote","limit","max_spatial","max_temporal","stop","RpcRequest","reqId","params","reject","createdAt","toJson","req_id","RPC","_socket","_reqSeed","_msgDecoder","TextDecoder","_handlers","_reqs","connected","_prereceiveMessage","Blob","reader_1","FileReader","onload","Uint8Array","decompressed","inflate","decode","_onReceiveMessage","readAsArrayBuffer","ArrayBuffer","byteLength","json","handler","req","success","cmd","delete","StreamSender","Deactivated","Session","_cfg","_connector","_audioSenders","_videoSenders","_audioReceivers","_videoReceivers","update","debounce","isImmediate","console","log","recvrTrack","createSender","createReceiver","takeReceiver","shift","backReceiver","getSender","socket","gateway"],"mappings":"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"}